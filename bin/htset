#!/usr/bin/ruby
#
# Hosttag update client, redis version
#
# Usage:
#   htset <host1> [<host2> ...] <tag> [<tag2> ...]
#

require 'optparse'
require 'ftools'
require 'pp'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '..', 'lib')
require 'hosttag/server'

# ------------------------------------------------------------------------------
# Subroutines

def die(error)
  puts error
  exit 1
end

def parse_options(me)
  options = { :all => 0 }
  opts = OptionParser.new
  opts.banner = "Usage: #{me} [options] <host> [<host2> ...] <tag> [<tag2>...]"
  opts.on('-?', '-h', '--help') do
    puts opts
    exit
  end
  opts.on('-h', '--help', '-?', 'Show this usage information') do
    die(opts)
  end
  opts.on('-A', '--all', '(htdel) Delete all tags from hosts') do
    options[:all] = 1
  end
  opts.on('-s=ARG', '--server=ARG', String, 'Server hostname to connect to') do |val|
    options[:server] = val
  end
  opts.on('-p=ARG', '--port=ARG', Integer, 'Server port to connect to') do |val|
    options[:port] = val
  end
  opts.on('--ns=STR', '--namespace=STR', String, 'Namespace into which we load hosttag data. Default: hosttag') do |val|
    options[:namespace] = val
  end
  opts.on('-v', '--verbose', 'Verbose output') do
    options[:verbose] = true
  end

  # Parse options
  begin
    args = opts.parse(ARGV) 
  rescue => e
    die(opts) 
  end

  if args.length < 2 and options[:all] != 1
    die(opts) 
  end
  if options[:all] == 1 and me == 'htset'
    warn "Error: --all not available with htset"
    die(opts)
  end 

  return options, args
end

# Classify args into hosts, tags, and uncertain buckets
def classify_args(r, args, options)
  results = { :host => [], :tag => [], :uncertain => [] }
  arg_type = 'host'
  verbose = options[:verbose]

  # First arg must be host, and last tag, by definition
  results[:host].push(args.shift)
  last_tag = args.pop

  # Classify remainder by checking for existence in redis
  while a = args.shift
    if r.exists(r.get_key(arg_type, a))
      if arg_type == 'host'
        # if 'a' is a valid host, then everything before 'a' must be too
        if results[:uncertain].length > 0
          results[:uncertain].each { |u| results[:host].push(u) }
          results[:uncertain] = []
        end
        results[:host].push(a)
      else
        results[:tag].push(a)
        # If 'a' is a valid tag, then everything after 'a' must be too
        args.each { |a| results[:tag].push(a) }
        break
      end

    elsif arg_type == 'host'
      # Not a host, see if it's a tag
      arg_type = 'tag'
      redo

    elsif arg_type == 'tag'
      # Not a host or a tag, add to uncertain list
      arg_type = 'host'
      results[:uncertain].push(a)
    end
  end

  results[:tag].push(last_tag)

  return results
end

def adjust_hosttags(r, hosts, tags, mode, verbose)
  # Add tags to each host
  hosts.each do |host|
    key = r.get_key('host', host)
    tags.each do |tag| 
      if (mode != 'htdel')
        r.sadd(key, tag) 
      else
        r.srem(key, tag) 
      end
    end
    skip_host = r.sismember(key, 'SKIP')
    r.del(key) if mode == 'htdel' and r.scard(key) == 0

    # Add/delete to/from all_hosts sets
    all_hosts = r.get_key('all_hosts')
    all_hosts_noskip = r.get_key('all_hosts_noskip')
    if (r.smembers(key).length > 0)
      r.sadd(all_hosts, host)
    else
      r.srem(all_hosts, host)
    end
    if (r.smembers(key).length > 0 and not skip_host)
      r.sadd(all_hosts_noskip, host)
    else
      r.srem(all_hosts_noskip, host)
    end
  end

  # Add/delete hosts to/from each tag
  tags.each do |tag|
    key = r.get_key('tag', tag)
    hosts.each do |host| 
      if (mode != 'htdel')
        r.sadd(key, host) 
      else
        r.srem(key, host) 
      end
    end
    r.del(key) if mode == 'htdel' and r.scard(key) == 0

    # Add/delete to/from all_tags sets
    all_tags = r.get_key('all_tags')
    all_tags_noskip = r.get_key('all_tags_noskip')
    if (r.smembers(key).length > 0) 
      r.sadd(all_tags, tag)
    else
      r.srem(all_tags, tag)
    end
    if (r.smembers(key).length > 0 and tag != 'SKIP') 
      r.sadd(all_tags_noskip, tag)
    else
      r.srem(all_tags_noskip, tag)
    end
  end
end

def delete_all_tags_for_hosts(r, args, options)
  args.each do |host|
    key = r.get_key('host', host)
    if r.exists(key)
      print "Delete all tags on host '#{host}'? [yN] "
      $stdout.flush
      confirm = $stdin.gets.chomp
      if confirm =~ %r{^y}i
        adjust_hosttags(r, [ host ], r.smembers(key), 'htdel', options[:verbose])
      end
    else
      warn "Warning: invalid host '#{host}' - cannot delete"
    end
  end
end

# ------------------------------------------------------------------------------
# Main

mode = $0.sub(/^.*\//, '')

options, args = parse_options(mode)

r = Hosttag::Server.new(options)

# Normal mode
if (options[:all] == 0)
  results = classify_args(r, args, options)
  if options[:verbose] 
    print "+ results: "
    pp results 
  end

  if results[:uncertain].length > 0
    # TODO: do something useful here - ask the user?
    die("Error: can't auto-classify '#{results[:uncertain].join(',')}' - aborting")
  end

  adjust_hosttags(r, results[:host], results[:tag], mode, options[:verbose]);

# htdel --all mode
else
  delete_all_tags_for_hosts(r, args, options)

end

