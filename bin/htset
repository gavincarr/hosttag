#!/usr/bin/ruby
#
# Hosttag update client, redis version
#
# Usage:
#   htset <host1> [<host2> ...] <tag> [<tag2> ...]
#

require 'optparse'
require 'ftools'
require 'pp'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '..', 'lib')
require 'hosttag/server'

# ------------------------------------------------------------------------------
# Subroutines

def die(error)
  puts error
  exit 1
end

def parse_options(me)
  opts = OptionParser.new
  opts.banner = "Usage: #{me} [options] <host> [<host2> ...] <tag> [<tag2>...]"
  opts.on('-?', '-h', '--help') do
    puts opts
    exit
  end
  opts.on('-h', '--help', '-?', 'Show this usage information') do
    die(opts)
  end
  opts.on('-s=ARG', '--server=ARG', String, 'Server hostname to connect to') do |val|
    options[:server] = val
  end
  opts.on('-p=ARG', '--port=ARG', Integer, 'Server port to connect to') do |val|
    options[:port] = val
  end
  opts.on('--ns=STR', '--namespace=STR', String, 'Namespace into which we load hosttag data. Default: hosttag') do |val|
    options[:namespace] = val
  end
  opts.on('-v', '--verbose', 'Verbose output') do
    options[:verbose] = true
  end

  # Parse options
  begin
    args = opts.parse(ARGV) 
  rescue => e
    die(opts) 
  end

  if args.length < 2
    die(opts) 
  end

  return options, args
end

# Classify args into hosts, tags, and uncertain buckets
def classify_args(r, args, options)
  results = { :host => [], :tag => [], :uncertain => [] }
  arg_type = 'host'
  verbose = options[:verbose]

  # First arg must be host, and last tag, by definition
  results[:host].push(args.shift)
  last_tag = args.pop

  # Classify remainder by checking for existence in redis
  while a = args.shift
    if r.key?(r.get_key(arg_type, a))
      if arg_type == 'host'
        # if 'a' is a valid host, then everything before 'a' must be too
        if results[:uncertain].length > 0
          results[:uncertain].each { |u| results[:host].push(u) }
          results[:uncertain] = []
        end
        results[:host].push(a)
      else
        results[:tag].push(a)
        # If 'a' is a valid tag, then everything after 'a' must be too
        args.each { |a| results[:tag].push(a) }
        break
      end

    elsif arg_type == 'host'
      # Not a host, see if it's a tag
      arg_type = 'tag'
      redo

    elsif arg_type == 'tag'
      # Not a host or a tag, add to uncertain list
      arg_type = 'host'
      results[:uncertain].push(a)
    end
  end

  results[:tag].push(last_tag)

  return results
end

def adjust_hosttags(r, hosts, tags, mode, verbose)
  # Add tags to each host
  hosts.each do |host|
    key = r.get_key('host', host)
    skip_host = false
    tags.each do |tag| 
      if (mode != 'htdel')
        r.set_add(key, tag) 
      else
        r.set_delete(key, tag) 
      end
      skip_host = true if tag == 'SKIP'
    end
    # Add/delete to/from all_hosts sets
    all_hosts = r.get_key('all_hosts')
    all_hosts_noskip = r.get_key('all_hosts_noskip')
    if (mode != 'htdel')
      r.set_add(all_hosts, host)
      if skip_host:
        r.set_delete(all_hosts_noskip, host)
      else
        r.set_add(all_hosts_noskip, host)
      end
    else
      r.set_delete(all_hosts, host)
      r.set_delete(all_hosts_noskip, host)
    end
  end

  # Add/delete hosts to/from each tag
  tags.each do |tag|
    key = "#{options[:namespace]}/tag/#{tag}" 
    hosts.each do |host| 
      if (mode != 'htdel')
        r.set_add(key, host) 
      else
        r.set_delete(key, host) 
      end
    end
    # Add to all_tags sets
    all_tags = r.get_key('all_hosts')
    all_tags_noskip = r.get_key('all_hosts_noskip')
    if (mode != 'htdel')
      r.set_add(all_tags, tag)
      r.set_add(all_tags_noskip, tag) unless tag == 'SKIP'
    else
      r.set_delete(all_tags, tag)
      r.set_delete(all_tags_noskip, tag) unless tag == 'SKIP'
    end
  end
end

# ------------------------------------------------------------------------------
# Main

mode = $0.sub(/^.*\//, '')

options, args = parse_options(mode)

r = Hosttag::Server.new(options)

results = classify_args(r, args, options)
if options[:verbose] 
  print "+ results: "
  pp results 
end

if results[:uncertain].length > 0
  # TODO: do something useful here - ask the user?
  die("Error: can't auto-classify '#{results[:uncertain].join(',')}' - aborting")
end

adjust_hosttags(r, results[:host], results[:tag], mode, options[:verbose]);

