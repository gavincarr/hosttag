#!/usr/bin/ruby
#
# Hosttag query client, redis version
#
# Usage:
#   ht <tag>
#
#   ht [-a] <tag1> <tag2>           Show hosts with tag1 AND tag2 (intersection, default)
#   ht -o <tag1> <tag2>             Show hosts with tag1 OR tags2 (union)
#
#   ht -A                           Show all hosts
#
#   ht -t <host>                    Show tags on 'host'
#   ht -t [-o] <host1> <host2>      Show tags on 'host' OR 'host2' (union, default)
#   ht -t -a <host1> <host2>        Show tags on 'host' AND 'host2' (intersection)
#
#   ht -T                           Show all tags
#

require 'rubygems'
require 'redis'
require 'optparse'

options = { 
  :arg_type => 'tag', :all => 0, :all_key => 'all_hosts', 
  :server => 'hosttag', :port => 6379,
}
arg_type_invert = { 'tag' => 'host', 'host' => 'tag' }

opts = OptionParser.new
opts.banner = "Usage: hosttag.rb [options] <tag> [<tag2>...]"
opts.on('-?', '-h', '--help') do
  puts opts
  exit
end
opts.on('-a', '--and', 'Report hosts with ALL the given tags (AND result sets)') do
  options[:rel] = 'and'
end
opts.on('-o', '--or',  'Report hosts with ANY of the given tags (OR result sets)') do
  options[:rel] = 'or'
end
opts.on('-t', '--tag', '--tags', "Tag mode: report tags for the given hosts") do
  options[:arg_type] = 'host'
end
opts.on('-A', '--all', 'Report all hosts') do
  options[:all] += 1
end
opts.on('-T', '--all-tags', 'Report all tags') do
  options[:all] += 1
  options[:all_key] = 'all_tags'
end
opts.on('-s=ARG', '--server=ARG', String, 'Server hostname to connect to') do |val|
  options[:server] = val
end
opts.on('-p=ARG', '--port=ARG', Integer, 'Server port to connect to') do |val|
  options[:port] = val
end
opts.on('-v', '--verbose', 'Verbose output') do
  options[:verbose] = true
end
def usage(opts)
  puts opts
  exit
end

# Parse options
begin
  args = opts.parse(ARGV) 
rescue => e
  puts "Error: " << e
  usage(opts)
end
if args.length == 0 and options[:all] == 0
  usage(opts) 
end

# Create redis object
r = Redis.new( :host => options[:server], :port => options[:port] )

def die(error)
  puts error
  exit 1
end

def lookup_keys(r, args, arg_type, rel, verbose)
  # Default a rel if we have multiple args
  if args.length > 1 and not rel
    rel = arg_type == 'tag' ? 'and' : 'or'
  end
  puts "+ rel (#{arg_type}): #{rel}" if verbose

  # Map keys to fetch
  keys = args.collect {|v| "hosttag/#{arg_type}/#{v}" }
  puts "+ keys: #{keys.join(' ')}" if verbose

  # Check all keys exist
  keys.each do |k| 
    if not r.key?(k) 
      item = k.sub(%r{^.*/}, '')
      raise "Error: #{arg_type} '#{item}' not found." 
    end
  end
  
  # Lookup and return
  if keys.length == 1
    r.set_members( keys ).sort.join(' ')
  elsif rel == 'and'
    r.set_intersect( keys ).sort.join(' ')
  else
    r.set_union( keys ).sort.join(' ')
  end
end

# Standard request
if options[:all] == 0
  begin
    result = lookup_keys(r, args, options[:arg_type], options[:rel], options[:verbose]);
  rescue
    die $! unless options[:arg_type] == 'tag'
    # If default lookups failed as a tag, try again as a host
    error1 = $!
    begin
      result = lookup_keys(r, args, arg_type_invert[options[:arg_type]], options[:rel], options[:verbose])
    rescue
      # Failed a second time - rethrow original error
      die error1
    end
  end

  # Report
  puts result.sort.join(' ')

# All request
else
  key = "hosttag/#{options[:all_key]}"
  key += "_noskip" if options[:all] == 1
  puts "+ key: #{key}" if options[:verbose]
  puts r.set_members(key).sort.join(' ');
end

